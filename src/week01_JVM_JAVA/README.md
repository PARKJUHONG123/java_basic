## 목표
	자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

## 학습할 것
### 1. JVM이란 무엇인가
- 운영체제는 자바 프로그램을 바로 실행할 수 없음
- 자바 프로그램은 완전한 기계어가 아닌, 중간 단계의 바이트 코드이기 때문에 이것을 해석하고 실행할 수 있는 가상의 운영체제가 필요
- 이러한 가상의 운영체제를 JVM (Java Virtual Machine)
- 여러 운영체제에서 동일한 결과가 나오도록 설계
- JDK (Java Development Kit) 또는 JRE (Java Runtime Environment) 를 설치하면 JVM이 자동으로 설치됨
- CPU와 독립적으로 동작 가능함

### 1-1. JAVA 특징
1. 동적 로딩 (Dynamic Loading)
- 자바 애플리케이션은 여러 개의 객체가 서로 연결되어 실행되는데, 이 객체들은 클래스로부터 생성됨
- 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적으로 로딩해서 객체를 생성함
- 따라서 수정이 필요할 때도 해당 클래스만 수정하면 되므로 전체 애플리케이션을 다시 컴파일할 필요가 없음

2. 용이한 멀티 스레드
- JVM에 의해 CPU나 운영체제에 독립적임
- JAVA는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하기 때문에 쉽게 사용가능

3. 함수적 스타일 코딩 지원
- JAVA8 부터 함수적 프로그래밍을 위해 람다식 (Lambda Expressions)를 지원함
- 이를 통해 컬렉션의 요소를 필터링, 매핑, 집계 처리하는데 쉬어지고, 코드가 간결해짐

4. 객체 지향 언어
- OOP (Object Oriented Programming) 을 위해 사용되는 언어
- 객체를 만들기 위해서 설계도인 클래스를 작성해야 하고, 객체와 객체를 연결하여 목적에 맞는 프로그램을 만듦
- 캡슐화, 상속, 다형성 기능을 지원함

5. 메모리를 자동으로 관리함
- Garbage Collector 를 실행시켜 자동적으로 사용하지 않는 객체를 제거함

### 2. 컴파일 하는 방법
- 소스 파일에 대한 한번의 컴파일로 바이트 코드 파일이 만들어짐
- 자바 실행 환경 JRE (Java Runtime Environment) 가 설치되어 있는 모든 운영체제에서 실행 가능함
- 따라서 자바 언어는 이식성이 높은 프로그래밍 언어

### 3. 실행하는 방법
1. 소스파일 (*.java) 를 컴파일러 (javac.exe) 가 컴파일한다
2. 컴파일 결과 바이트 코드 파일 (*.class) 가 생성된다
3. 바이트 코드 파일은 JVM 구동 명령어 (java.exe) 에 의해 JVM에서 해석되고, JVM은 바이트 코드 파일을 메모리로 로드하고 각 운영체제에서 실행할 수 있는 기계어로 번역한다.

- 자바 소스파일은 src 디렉토리에, 바이트 코드 파일은 bin 디렉토리에 기본적으로 저장된다.

### 3-1. 실행 예시
1. 아래 코드를 가진 hello.java 파일을 생성한다.

```
public class hello {
	public static void main(String[] args) {
    	System.out.println("Hello Java");
    }
}
```

2. javac hello.java 를 입력하여 소스파일을 컴파일한다. 그 결과 hello.class 바이트 코드 파일이 생성된다.
3. java hello 를 입력하여 JVM 구동 명령어 java.exe를 통해 기계어로 번역한다.


### 4. 바이트코드란 무엇인가
- 바이트 코드는 모든 JVM에서 동일한 실행 결과를 보장하지만, JVM은 운영체제에 종속적
- 즉 바이트 코드는 JVM에 독립적이지만, JVM은 운영체제에 종속적
- 자바 프로그램을 운영체제가 이해하는 기계어로 번역해서 실행해야 하므로 JVM은 운영체제에 맞게 설치되어야 함
- 바이트 코드 파일을 완전한 기계어가 아니므로 단독으로 실행할 수 없고 JVM이 실행되어야 함
- JVM을 구동시키는 명령어는 java.exe 이지만, java.exe로 바이트 코드 파일을 실행할 때는 .class 확장명을 제외한 이름을 입력해야 함
- 바이트 코드 컴파일러가 시간이 많이 소요되는 최적화를 미리 해주기 때문에 바이트 코드에서 기계어 번역은 훨씬 빠르게 진행됨
- 이식성이 뛰어나면서 기계어로 빠르게 해석될 수 있음

### 5. JIT 컴파일러란 무엇이며 어떻게 동작하는지
1. 개념
- JIT (Just-In-Time) 컴파일러
- 바이트 코드를 CPU로 직접 보낼 수 있는 명령어로 바꾸는 프로그램
- 성능 최적화를 위해 애플리케이션 런타임을 향상시킬 수 있음 (속도 결정에 핵심)
- 데이터 분석, 스택 작업에서 레지스터 작업으로의 변환, 레지스터 할당에 의한 메모리 액세스 감소, 공통 하위 표현식 제거 등의 최적화 작업
- Java 애플리케이션의 성능을 향상시키는 JRE의 구성 요소

2. 특징
- JIT 컴파일링은 최초 실행될 때 최초 실행되기 때문에, 최초실행에서는 조금 느릴 수 있음
- 컴파일 없이 Interpret만 하는 경우보다 반복적인 작업을 할 때 훨씬 높은 성능 가능
- JIT 컴파일러가 수행하는 최적화 수준이 높을수록 실행 단계에서 더 많은 시간 소요
- 메소드가 덜 자주 실행되지 않는 한. JIT 컴파일러가 바이트 코드를 컴파일하는 데 걸리는 시간은 전체 실행 시간에 추가되며 JIT에 의해 컴파일 된 메서드가 자주 호출되지 않으면 바이트 코드를 실행하는 인터프리터보다 실행 시간이 길어질 수 있음
- 다른 컴파일러 유형과 달리, 프로그램이 시작되고 코드를 컴파일한 후에 JIT 컴파일러를 실행함
- 정적 컴파일러가 수행하는 모든 최적화를 수행할 여유는 없음

3. 방법
- 자바 컴파일러가 자바 프로그램 코드를 바이트코드로 변환한 다음, 실제 바이트코드를 실행하는 시점에서 JVM이 바이트코드를 JIT 컴파일을 통해 기계어로 변환
- 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지
- 즉 정적 컴파일처럼 빠르면서도 매번 컴파일을 다시 할 필요없는 동적 컴파일 환경을 구성함으로서 실행 과정에서 컴파일을 할 수 있음

4. 컴파일 단계
- 인라이닝
  : 더 작은 메서드의 트리를 호출자의 트리에 병합하거나 인라인하는 프로세스로 자주 실행되는 메서드 호출 속도가 빨라짐

- 로컬 최적화
  : 한번에 코드의 작은 부분을 분석하고 개선함

- 제어 흐름 최적화
  : 메서드 내부의 제어 흐름을 분석하고 코드 경로를 재정렬하여 효율성 향상

- 글로벌 최적화
  : 전역 최적화는 전체 방법에서 한 번에 작동함 / 시간적, 공간적 비용이 크지만 성능이 크게 향상될 수 있음

- 네이티브 코드 생성
  : 메서드의 트리가 기계어 코드 명령어로 변환됨

### 6. JVM 구성 요소
- Class Loader
    - 자바 컴파일러가 .java 파일을 컴파일하면 .class 파일이 생성되는데, 이렇게 생성된 바이트 코드 (클래스 파일)들을 엮어 Runtime Data Area 형태로 메모리에 적재하는 역할

- Garbage Collector
    - Heap 메모리 영역에 생성된 객체들 중에 주소를 잃어버려서 사용할 수 없는 객체를 탐색 후 제거하는 역할
    - Stop-the-world : GC 실행을 위해 JVM이 애플리케이션 실행을 멈춤
        - GC 실행 스레드 제외 모든 스레드들이 작업을 멈춤
        - GC 튜닝은 이 시간을 줄이는 것을 의미함
    - GC 과정 : Mark and Sweep
        - Mark : GC가 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정
        - Sweep : Mark 되어 있지 않은 객체들을 Heap에서 제거하는 과정

- Execute Engine
  : 메모리에 적재된 클래스들을 기계어로 변경해서 명령어 단위로 실행하는 역할
    - 명령어를 하나하나 실행하는 인터프리터 방식
    - 기계어로 변환시켜놓고 저장해서 사용하는 JIT 방식

- Runtime Data Area (Class Loader, Garbage Collector, Execution Engine 이 참조함)
    - Method Area
        - 클래스 맴버 변수, 메소드 정보, Type (Class, Interface) 정보, Constant Pool, static 변수, final 변수 등이 생성됨
        - Constant Pool은 모든 Symbolic Reference를 포함
    - Heap Area
        - Young 영역 : 새롭게 생성한 객체가 위치
        - Old 영역 : Young 영역에서 Reachable 상태를 유지해 살아남은 객체가 복사되는 영역
        - Perm 영역 : 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역 (= Method Area)
    - Stack Area
        - 지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시값 등을 저장하는 영역
        - 동적으로 객체를 생성하면 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장됨
        - Stack은 스레드별로 독자적으로 가짐
        - Heap에 있는 오브젝트가 Stack에서 참조할 수 없는 경우 GC의 대상이 됨
        - 클래스 A a = new A()의 경우 A a는 Stack 영역에 저장되고, new로 생성된 A클래스의 인스턴스는 Heap 영역에 생성됨
        - a가 Heap 영역에 생성된 객체를 가리키며 참조함
        - 메소드 호출시마다 개별적으로 Stack이 생성됨

    - PC register
        - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있음
        - CPU의 PC Register와는 다름
    - Native Method Stack
        - 자바 외의 언어로 작성된 Native Code를 위한 메모리 영역
        - 자바에는 하드웨어를 직접 제어하는 기능이 없기 때문에, 필요한 경우 C언어와 같은 다른 언어의 기능을 빌려 사용함
        - 이 때 사용하는 기술이 JNI (Java Native Interface) 기술로 네이티브 메소드들이 바이트 코드로 변환되면서 사용되고 기록하는 영역

### 7. JDK와 JRE의 차이
1. JRE : Java Runtime Environment = 자바 실행 환경
- JVM + 표준 클래스 라이브러리
- 프로그램 실행에 필요한 자바 가상 기계 (JVM), 라이브러리 API만 포함되어 있음
- 자바 프로그램을 개발하고자 하는 것이 아니고, 이미 개발된 프로그램만 실행하는 경우

2. JDK : Java Development Kit = 자바 개발 키트
- JRE + 개발에 필요한 도구
- 프로그램 개발에 필요한 JVM, 라이브러리 API, 컴파일러 등 개발 도구 포함
- 단, 웹 브라우저에서 실행하는 애플릿 (Applet)은 JRE를 요구하기 때문에 애플릿을 개발한다면 JRE도 필요하다
- JDK 내부의 bin 디렉토리는 컴파일러인 javac.exe와 JVM 구동 명령어인 java.exe가 포함되어 있음
